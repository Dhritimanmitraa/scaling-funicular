# Gyan-Ai

## Project Description
Project: "Gyan AI" - The AI-Powered Learning Companion (MVP)
The goal of this MVP is to build the core functionality of an educational app that validates the primary user journey: selecting a topic, learning from a video, and testing knowledge with a quiz.

Core MVP Features
User Onboarding: Simple email/password registration and login.

Curriculum Selection: Users must select their educational board (CBSE, State, ICSE) and their class (5th-10th) after signing up. This choice will be saved to their profile.

Content Navigation: A clear, hierarchical path for users to browse Subjects (e.g., Physics, History) and then the Chapters within that subject.

AI-Generated Video Lesson: Each chapter page will feature a "Watch Lesson" button that loads a short, AI-generated video explaining the core concepts of the chapter.

AI-Generated Chapter Quiz: After watching the video, users can take a short multiple-choice quiz to assess their understanding of the chapter content.

User Stories for the MVP
As a new student, I want to create an account and select my board and class so that I see content relevant to my studies.

As a student, I want to easily navigate through my subjects and chapters so that I can find the topic I need to study.

As a student, I want to watch a concise video for each chapter so that I can quickly understand the main concepts.

As a student, I want to take a quiz after the lesson so that I can check if I have understood the material correctly.

Proposed Tech Stack & Architecture
This architecture focuses on using modern, scalable, and API-driven services to achieve the MVP goals efficiently.

1. Frontend (The Mobile App)

Technology: Flutter & Dart

Role:

Build a single, beautiful, and responsive user interface that runs on both Android and iOS from one codebase.

Manage user state (e.g., who is logged in).

Handle all user interactions, from login to navigating chapters and taking quizzes.

Communicate with the backend via REST APIs to fetch data (like the list of subjects) and send data (like quiz answers).

2. Backend (The Brains)

Technology: A lightweight server framework (like Node.js with Express, or Python with FastAPI) that connects to Neon.

Role:

Create the API endpoints that the Flutter app will call.

Handle business logic, such as user authentication (checking passwords) and fetching the correct curriculum structure from the database.

Orchestrate calls to the AI services (OpenRouter and Fal.ai) to generate content on demand.

3. Database (The Memory)

Technology: Neon (Serverless Postgres)

Role:

Store all structured data for the application.

Key Tables for MVP:

users: Stores user login info and their chosen board and class.

curriculum: A table that outlines the structure of boards, classes, subjects, and chapters.

content: Stores pointers to the generated content, like the URL of the video generated by Fal.ai and the questions for a quiz.

4. Generative APIs (The Magic)

Quiz Generation: OpenRouter

Role: To act as a flexible gateway to various powerful Large Language Models (LLMs).

Workflow: When a student wants to take a quiz, the backend sends a carefully crafted prompt to the OpenRouter API.

Example Prompt: "Generate 5 unique multiple-choice questions with 4 options and a correct answer for a 7th-grade CBSE student on the chapter 'Properties of Triangles'. Return the response in JSON format."

The backend then receives this structured JSON and forwards it to the Flutter app to display the quiz.

Video Generation: Fal.ai

Role: To programmatically create short educational videos from text prompts.

Workflow: This is the most innovative and complex part. For the MVP, we can assume a simplified flow:

The backend first uses OpenRouter to generate a short, simple script or a list of key points for a chapter.

It then sends this script to the Fal.ai API with a prompt.

Example Prompt: "Create a 90-second animated educational video explaining the water cycle for a 5th-grade student using this script: [script from OpenRouter]..."

Fal.ai will process this and return a video file. This video is then saved to a cloud storage service (like Google Cloud Storage or AWS S3), and the URL is stored in our Neon database. The Flutter app simply plays the video from this URL.

This MVP setup creates a fully functional, AI-powered learning loop while remaining focused and achievable. It leverages modern, scalable tools to build a foundation that can be expanded upon with more features in the future.



## Product Requirements Document
Gyan-AI Product Requirements Document (PRD)

1.0 Introduction/Executive Summary
Gyan-AI is an AI-powered learning companion designed to make education accessible, engaging, and personalized for students in India. This Product Requirements Document (PRD) outlines the scope, features, and technical specifications for the Minimum Viable Product (MVP) of Gyan-AI. The MVP focuses on validating the core user journey: selecting a topic, learning from an AI-generated video, and testing knowledge with an AI-generated quiz, specifically for students in classes 5th-10th across major Indian educational boards.

2.0 Goals & Objectives (MVP)
The primary goal of the Gyan-AI MVP is to build a foundational, AI-powered learning application that effectively addresses key student and parent pain points related to curriculum-aligned content, cost, and engagement.

MVP Launch Success Metrics (First 3 Months):
* User Acquisition & Activation:
    * Achieve 10,000+ downloads from the App Stores.
    * Activation Rate: > 60% of users who download the app complete the registration and curriculum selection process.
* User Engagement & Retention:
    * Day 7 Retention: > 20% of new users return to the app within the first week.
    * Core Loop Engagement: > 50% of active users watch at least one video and attempt one quiz per week.
    * Average Videos Watched per User: 3+
    * Quiz Completion Rate: > 70% of quizzes started are completed.
* Qualitative Feedback:
    * App Store Rating: Achieve an average rating of 4.2 stars or higher.

3.0 Target Audience/Personas
The MVP targets students and their parents in India, primarily focusing on addressing the academic needs and financial concerns within this demographic.

Primary Persona: "Rohan" (The Student)
* Demographic Profile: A 13-year-old student, residing in a Tier-2 Indian city. Tech-savvy but easily distracted.
* Psychographic Profile: Needs clear, concise, and curriculum-aligned educational material to aid in understanding school topics and improve academic performance. Values engaging content over dry textbooks. Seeks quick concept explanations and self-assessment tools.

Secondary Persona: "Sunita" (The Parent)
* Demographic Profile: A working parent, age 35-45, living in a Tier-2 Indian city. Moderately tech-literate (uses WhatsApp, PayTM).
* Psychographic Profile: Aspirational for her child's future, concerned about academic performance, and budget-conscious. Seeks value for money and trusts structured, curriculum-aligned learning. Wary of uncontrolled online content.
* Primary Pain Points Addressed by Gyan-AI:
    * High Cost of Private Tuition: Gyan-AI offers a more affordable, on-demand supplement to traditional learning methods.
    * Lack of Transparency: Provides a structured learning environment where content is specific and progress can be inferred (though detailed parent reporting is post-MVP).
    * Content Overload & Distraction: Offers an ad-free, focused learning experience, reducing exposure to irrelevant content and advertisements.
    * Quality & Relevance: Ensures content is accurate and directly mapped to the school's CBSE/ICSE syllabus.
* Replaces/Improves Upon:
    * Disorganized Online Videos (e.g., YouTube)
    * Expensive EdTech Subscriptions (e.g., Byju's, Vedantu)
    * Private Tuition (by offering a scalable, consistent alternative)

4.0 Problem Statement
Students in India, particularly those in middle school, face challenges accessing high-quality, curriculum-aligned educational content that is both engaging and affordable. Existing solutions often suffer from high costs (private tuition, premium EdTech apps), content overload and distractions (free online platforms), or a lack of direct relevance to school syllabi. Parents struggle with the financial burden of supplementary education and the uncertainty of content quality and child engagement when using online resources.

5.0 Solution Overview (MVP Features)
Gyan-AI's MVP will deliver a focused, AI-powered mobile learning experience centered around a clear learning loop: curriculum selection, video lesson, and quiz assessment.

Core MVP Features:
1. User Onboarding: Simple email/password registration and login.
2. Curriculum Selection: Users select their educational board (CBSE, State, ICSE) and class (5th-10th) upon signup, which is saved to their profile.
3. Content Navigation: A clear, hierarchical interface to browse Subjects (e.g., Physics, History) and Chapters within each subject.
4. AI-Generated Video Lesson: Each chapter page features a "Watch Lesson" button that loads a short, AI-generated video explaining the core concepts.
5. AI-Generated Chapter Quiz: After watching a video, users can take a short multiple-choice quiz to assess their understanding.
6. Basic Gamification: A simple points system for completing lessons/quizzes and a "daily streak" counter.

6.0 User Stories for the MVP
* As a new student, I want to create an account and select my board and class so that I see content relevant to my studies.
* As a student, I want to easily navigate through my subjects and chapters so that I can find the topic I need to study.
* As a student, I want to watch a concise video for each chapter so that I can quickly understand the main concepts.
* As a student, I want to take a quiz after the lesson so that I can check if I have understood the material correctly.

7.0 Functional Requirements

7.1 User Onboarding & Profile Management
* FR1.1 Registration: Users can create an account using their email address and a password.
* FR1.2 Login: Users can log in using their registered email and password.
* FR1.3 Profile Setup (Initial): Upon first login, users must select their educational board (CBSE, State, ICSE) and class (5th-10th).
* FR1.4 Profile Storage: The selected board and class must be persistently saved to the user's profile.

7.2 Curriculum Navigation
* FR2.1 Dashboard: Display a dashboard showing selected board/class, and entry points to subjects.
* FR2.2 Subject List: Users can view a list of subjects relevant to their selected board and class.
* FR2.3 Chapter List: Upon selecting a subject, users can view a list of chapters within that subject.
* FR2.4 Chapter Details: Each chapter page will display the chapter name, a "Watch Lesson" button, and a "Take Quiz" button (initially disabled until video watched).

7.3 AI-Generated Video Lessons
* FR3.1 Video Generation Trigger: When a user taps "Watch Lesson" for a chapter, the backend checks for an existing video. If none, it initiates the video generation process.
* FR3.2 Content Script Generation: The backend uses OpenRouter to generate a concise script or key points for the chapter based on the chapter name, board, and class.
* FR3.3 Video Generation: The generated script is sent to Fal.ai API to create a short, animated educational video.
* FR3.4 Video Storage: The generated video file is stored in a cloud storage service (e.g., Google Cloud Storage or AWS S3).
* FR3.5 Video Metadata Storage: The video URL and duration are stored in the `content` table in Neon DB, linked to the chapter.
* FR3.6 Video Playback: The Flutter app fetches the video URL and streams it to the user.
* FR3.7 Loading Indicator: A clear loading indicator is displayed while the video is being generated/fetched.
* FR3.8 Video Completion Tracking: The system tracks when a user has completed watching a video lesson.

7.4 AI-Generated Chapter Quizzes
* FR4.1 Quiz Generation Trigger: After a user completes a video, the "Take Quiz" button becomes active. When tapped, the backend checks for an existing quiz. If none, it initiates quiz generation.
* FR4.2 Quiz Question Generation: The backend uses OpenRouter to generate 5 multiple-choice questions with 4 options and a correct answer for the chapter, tailored to the user's board and class.
* FR4.3 Quiz Metadata Storage: The generated quiz questions, options, and answers are stored as JSONB in the `content` table in Neon DB, linked to the chapter.
* FR4.4 Quiz Display: The Flutter app fetches and displays the quiz questions to the user.
* FR4.5 Answer Submission: Users can select one option for each question and submit their answers.
* FR4.6 Quiz Scoring: The backend calculates the user's score based on correct answers.
* FR4.7 Score Display: The user's score and correct/incorrect answers are displayed immediately after submission.
* FR4.8 Quiz Attempt Tracking: The system stores details of each quiz attempt (user, quiz, score, total questions, timestamp) in the `quiz_attempts` table.

7.5 User Progress & Gamification
* FR5.1 Lesson Completion Tracking: After a user completes a video, an entry is made in the `user_progress` table.
* FR5.2 Points System: Users earn points for completing a video lesson and for each correct answer in a quiz.
* FR5.3 Daily Streak: The app tracks and displays a "daily streak" for consecutive days of app usage (e.g., watching a video or attempting a quiz).

8.0 Non-Functional Requirements (NFRs)

8.1 Performance & Scalability
* NFR8.1.1 Availability: The system will maintain a 99.5% uptime.
* NFR8.1.2 API Response Time: Backend API calls for data retrieval (e.g., fetching chapter lists) must have a response time of < 200ms.
* NFR8.1.3 Quiz Generation Latency: The user should see the first quiz question within 5 seconds of requesting a quiz (assuming no prior generation).
* NFR8.1.4 Video Generation Latency: AI-generated videos should be ready to stream within 30-60 seconds for a first-time generation. Subsequent views should be near-instantaneous due to caching. A loading indicator will be shown.
* NFR8.1.5 Data Consistency: Strong consistency is required for user profiles, authentication, and curriculum data to ensure immediate and accurate reflections of changes.
* NFR8.1.6 Scalability: All backend services will be deployed in a serverless architecture (e.g., Node.js/Express functions, Neon DB) to automatically scale with anticipated peak concurrent loads of 500-1,000 users for an MVP targeting 10,000 users.
* NFR8.1.7 AI Load Handling: The system must handle 5-10 new content generation requests per second during peak hours. Crucially, content (video/quiz) generated for a chapter must be cached/stored and reused for all subsequent users to minimize AI API calls and latency.

8.2 Security
* NFR8.2.1 Authentication: User passwords will be securely hashed and salted. Authentication will use industry-standard practices (e.g., JWTs for API authentication).
* NFR8.2.2 Data Protection: All sensitive user data (passwords, email) will be encrypted at rest and in transit.
* NFR8.2.3 Authorization: Users can only access content and progress data related to their own profile.

8.3 Reliability & Error Handling
* NFR8.3.1 AI Service Failure (API Errors/Timeouts):
    * Backend: Implement an exponential backoff retry mechanism (e.g., retry after 2s, then 4s, then 8s) for AI API calls.
    * Frontend: If all retries fail, display "Oops! We couldn't generate the content right now. Please check your connection and try again in a moment." with a "Retry" button.
* NFR8.3.2 Inappropriate Content Generation: Implement a "Report Content" button. Reported content will be flagged for manual review. For MVP, no automated moderation.
* NFR8.3.3 Fallback Content: For the MVP, there will be no fallback content if AI generation fails; an error message will be displayed.
* NFR8.3.4 Client-Side Network Issues: The Flutter app will detect offline status using `connectivity_plus` and display a dedicated message: "You seem to be offline. Please connect to the internet to continue learning."

8.4 Usability & Accessibility
* NFR8.4.1 Brand Identity:
    * Name: Gyan AI
    * Personality: Encouraging, Modern, Simple, Trustworthy.
    * Aesthetic: Clean, minimalist, and colorful (without being distracting).
    * Color Palette: Primary: Deep blue (#4A90E2); Secondary/Accent: Vibrant orange (#F5A623); Neutrals: Light gray (#F2F2F7) and dark gray (#333333).
    * Typography: Poppins or Lato (clean, friendly, readable sans-serif).
* NFR8.4.2 Design Inspirations: Duolingo (card-based UI, gamification), Khan Academy (content-first).
* NFR8.4.3 Usability Heuristics: Prioritize Nielsen's Usability Heuristics, especially "Aesthetic and minimalist design" and "Consistency and standards."
* NFR8.4.4 Accessibility: Target WCAG 2.1 Level AA compliance, ensuring sufficient color contrast, large tap targets (minimum 44x44 dp), and text alternatives for icons.

9.0 Technical Architecture & Stack

9.1 High-Level Architecture
The architecture leverages modern, scalable, and API-driven services, consisting of a Flutter mobile frontend, a lightweight serverless backend, a serverless PostgreSQL database, and external generative AI APIs.

9.2 Components & Technologies

* 9.2.1 Frontend (Mobile App)
    * Technology: Flutter & Dart
    * Role:
        * Cross-platform UI for Android and iOS.
        * User state management (login session).
        * Handles user interactions (navigation, video playback, quiz submission).
        * Communicates with backend via REST APIs.

* 9.2.2 Backend (Application Logic & Orchestration)
    * Technology: A lightweight server framework (e.g., Node.js with Express, or Python with FastAPI) deployed as serverless functions.
    * Role:
        * Provides REST API endpoints for the Flutter app.
        * Manages user authentication and authorization.
        * Fetches curriculum structure from the database.
        * Orchestrates calls to OpenRouter (for quiz/script generation) and Fal.ai (for video generation).
        * Stores generated content metadata and video URLs.

* 9.2.3 Database (Data Persistence)
    * Technology: Neon (Serverless PostgreSQL)
    * Role: Stores all structured application data.
    * Key MVP Schema (Detailed in 9.3): `boards`, `classes`, `subjects`, `chapters`, `users`, `content`, `user_progress`, `quiz_attempts`.

* 9.2.4 Generative APIs (AI Content Creation)
    * Quiz Generation: OpenRouter
        * Role: Gateway to various LLMs for generating quiz questions from prompts.
        * Workflow: Backend sends a prompt (e.g., "Generate 5 MCQs for 7th-grade CBSE on 'Properties of Triangles'") and receives structured JSON.
    * Video Generation: Fal.ai
        * Role: Programmatically creates short educational videos from text scripts.
        * Workflow: Backend first generates a script using OpenRouter, then sends it to Fal.ai with a prompt (e.g., "Create a 90-second animated educational video explaining the water cycle using this script..."). Fal.ai returns a video file, which is saved to cloud storage, and its URL stored in the DB.

9.3 Detailed Schema Requirements (Neon DB)

* Table: `boards`
    * `id` (PK, UUID)
    * `name` (VARCHAR, e.g., "CBSE", "ICSE")

* Table: `classes`
    * `id` (PK, UUID)
    * `board_id` (FK to `boards.id`)
    * `class_number` (INTEGER, e.g., 5, 6, 10)

* Table: `subjects`
    * `id` (PK, UUID)
    * `class_id` (FK to `classes.id`)
    * `name` (VARCHAR, e.g., "Physics", "History")

* Table: `chapters`
    * `id` (PK, UUID)
    * `subject_id` (FK to `subjects.id`)
    * `name` (VARCHAR, e.g., "Laws of Motion")
    * `chapter_number` (INTEGER)

* Table: `content`
    * `id` (PK, UUID)
    * `chapter_id` (FK to `chapters.id`)
    * `content_type` (ENUM, 'video', 'quiz')
    * `content_data` (JSONB)
        * For video: `{\"video_url\": \"...\", \"duration\": 180}`
        * For quiz: `{\"questions\": [{\"q\": \"...\", \"options\": [...], \"answer\": ...}]}`
    * `created_at` (TIMESTAMP)

* Table: `users`
    * `id` (PK, UUID)
    * `email` (VARCHAR, UNIQUE)
    * `password_hash` (VARCHAR)
    * `selected_board_id` (FK to `boards.id`, NULLABLE until selected)
    * `selected_class_id` (FK to `classes.id`, NULLABLE until selected)
    * `points` (INTEGER, DEFAULT 0)
    * `current_streak` (INTEGER, DEFAULT 0)
    * `last_active_date` (DATE)

* Table: `user_progress`
    * `id` (PK, UUID)
    * `user_id` (FK to `users.id`)
    * `content_id` (FK to `content.id` where `content_type` is 'video')
    * `status` (ENUM, 'completed')
    * `completed_at` (TIMESTAMP)

* Table: `quiz_attempts`
    * `id` (PK, UUID)
    * `user_id` (FK to `users.id`)
    * `quiz_content_id` (FK to `content.id` where `content_type` is 'quiz')
    * `score` (INTEGER)
    * `total_questions` (INTEGER)
    * `attempted_at` (TIMESTAMP)

9.4 Supporting Infrastructure
* CI/CD (Continuous Integration/Continuous Deployment):
    * GitHub Actions pipeline for automated linting, testing, building, and deployment (Flutter to TestFlight/Google Play Internal Testing; backend to staging).
    * Manual approval for production deployment.
* Logging, Monitoring & Error Reporting:
    * Logging: Centralized backend logging (e.g., AWS CloudWatch).
    * Monitoring: Grafana or similar for backend performance and infrastructure health.
    * Error Reporting: Sentry integrated with both Flutter app and backend for real-time error capture.
* Automated Testing Strategy:
    * Unit Tests: Mandatory for backend functions and Flutter widgets.
    * Integration Tests: Ensure Flutter-backend API communication in CI/CD.
    * End-to-End (E2E) Tests: Using Flutter's `integration_test` for critical user flows (Registration, Login, Complete Quiz).
* Environment Management:
    * Development (dev): Local environment.
    * Staging (staging): Production mirror for final testing.
    * Production (prod): The live environment for users.

10.0 Third-Party Integrations

10.1 Required for MVP:
* Analytics: Firebase Analytics (tracking user events, screen views, conversion funnels).
* Error Reporting: Sentry (real-time crash and error reporting for frontend and backend).
* Generative AI:
    * OpenRouter (LLM gateway for quiz and script generation).
    * Fal.ai (API for video generation from scripts).

10.2 Planned for Near Future (Post-MVP):
* Push Notifications: Firebase Cloud Messaging (FCM) for user re-engagement.
* External Authentication: Google Sign-In and Sign in with Apple for simplified login.
* CDN for Video Streaming: AWS CloudFront or similar for optimized video delivery as user base grows.

11.0 Future Enhancements (Post-MVP)

11.1 Short-Term Goals & Vision (6-12 months):
* Content Expansion: Extend curriculum to Classes 11-12 and incorporate more state boards based on user demand.
* Personalization: Implement a basic recommendation engine (e.g., "Students who watched this also found this chapter helpful").
* Parent Module: Develop a simple parent dashboard to track child's progress (chapters completed, quiz scores).
* Performance Analytics: Provide students with basic analytics on their quiz performance, highlighting strong and weak areas.

11.2 Long-Term Goals & Vision (2-5 years):
* Comprehensive Learning Ecosystem: Evolve into a full-fledged platform with adaptive learning paths, live doubt-clearing sessions, and peer-to-peer learning forums.
* AI-Powered Personal Tutor: Leverage user performance data to create truly personalized learning journeys, identifying knowledge gaps and suggesting specific remedial content.
* Market Expansion: Expand into adjacent markets like competitive exam preparation (JEE, NEET, UPSC).
* Monetization: Introduce a freemium model (free content, premium subscription for advanced features, full access, personalized analytics).

12.0 Timeline & Budget Constraints

12.1 Estimated MVP Timeline: 14 Weeks (Aggressive but feasible)
* Phase 1: Foundation & Backend (Weeks 1-3): DevOps setup, Neon schema, backend boilerplate, User Auth & Curriculum endpoints.
    * Milestone: Dev team can register a user and fetch subjects via API.
* Phase 2: Frontend UI & Navigation (Weeks 4-7): Flutter UI development with dummy data, navigation flow implementation.
    * Milestone: Complete, clickable app prototype for internal review.
* Phase 3: AI & API Integration (Weeks 8-12): Flutter-backend API connection, backend AI logic (OpenRouter, Fal.ai), live video player & quiz integration.
    * Milestone: Core learning loop fully functional on staging environment.
* Phase 4: Testing, Bug Fixing & Launch Prep (Weeks 13-14): E2E testing, bug fixing, performance optimization, app store listing preparation.
    * Milestone: MVP deployed to production and available on app stores.

12.2 Budget Constraints:
* Primary Recurring Costs: Usage-based pricing for OpenRouter and Fal.ai. Strict monitoring and alerting for these costs are essential.
* Infrastructure: Serverless stack (Flutter, Neon, serverless backend functions) chosen for cost-effectiveness, minimizing fixed infrastructure costs during MVP.
* Scope Management: MVP scope is tightly controlled to fit the timeline and budget. Feature creep will necessitate re-evaluation of the launch date or budget.

13.0 Assumptions & Dependencies
* AI API Reliability & Performance: Assumed OpenRouter and Fal.ai will maintain their stated performance, availability, and cost structures.
* Content Generation Quality: Assumed that the prompts crafted for OpenRouter and Fal.ai will consistently produce high-quality, educationally accurate, and age-appropriate content for the specified curriculum.
* Curriculum Data Availability: Assumed that the backend can be pre-populated with the full curriculum structure (boards, classes, subjects, chapters) for classes 5-10.
* Developer Resource Availability: Assumed a dedicated development team is available for the 14-week period.
* Mobile OS Compatibility: Assumed target Android and iOS versions are adequately covered by Flutter and associated libraries.

## Technology Stack
Gyan-Ai Technology Stack Documentation

1.  OVERVIEW

This document outlines the core and supporting technology stack for "Gyan-Ai", the AI-Powered Learning Companion MVP. The choices reflect a commitment to building a scalable, efficient, and maintainable educational platform, prioritizing rapid development for the MVP while laying a robust foundation for future expansion. The selection focuses on modern, API-driven, serverless, and cost-effective solutions.

2.  CORE TECHNOLOGY STACK

2.1. Frontend (Mobile Application)

*   **Technology**: Flutter & Dart
*   **Role**: To build a single, cross-platform mobile application (Android & iOS) with a rich and responsive user interface. It manages user state, handles all user interactions (login, navigation, quizzes), and communicates with the backend via REST APIs.
*   **Justification**:
    *   **Rapid Cross-Platform Development**: A single codebase significantly accelerates MVP delivery for both Android and iOS, aligning with the aggressive 14-week timeline.
    *   **Performance & UI/UX**: Flutter offers near-native performance and highly customizable widgets, enabling a clean, minimalist, and colorful aesthetic as per UI/UX preferences, inspired by apps like Duolingo and Khan Academy.
    *   **Developer Experience**: Dart is a modern, efficient language, and Flutter's hot-reload feature speeds up development cycles.

2.2. Backend (API Services & Business Logic)

*   **Technology**: Node.js with Express
*   **Role**: To serve as the application's brain, exposing REST API endpoints consumed by the Flutter app. It handles business logic, including user authentication, curriculum structure retrieval, and orchestrates calls to external AI services (OpenRouter and Fal.ai) for content generation.
*   **Justification**:
    *   **Lightweight & Efficient**: Express provides a minimalist framework suitable for building high-performance APIs. Node.js's asynchronous, event-driven architecture is ideal for I/O-bound tasks, such as making calls to multiple external AI APIs.
    *   **Scalability**: Well-suited for serverless deployment, allowing automatic scaling with user load, which aligns with anticipated peak usage patterns (500-1,000 concurrent users).
    *   **Ecosystem**: A vast ecosystem of libraries and strong community support for faster development and easier maintenance.

2.3. Database (Data Persistence)

*   **Technology**: Neon (Serverless PostgreSQL)
*   **Role**: To store all structured data, including user profiles (login info, board/class selections), the entire curriculum hierarchy (boards, classes, subjects, chapters), and pointers/data for generated content (video URLs, quiz questions). It also tracks user progress and quiz attempts.
*   **Justification**:
    *   **PostgreSQL Robustness**: Offers strong consistency, reliability, and advanced features (e.g., JSONB for flexible `content_data` storage) crucial for accurate educational content and user data.
    *   **Serverless by Design**: Neon's serverless architecture minimizes fixed infrastructure costs, scales automatically with demand, and ensures high availability (99.5% uptime SLA). This is critical for cost-effectiveness during the MVP phase.
    *   **Schema Flexibility**: Supports the detailed schema requirements for curriculum management and user progress tracking.

2.4. Generative AI APIs (Content Creation)

*   **Technology**: OpenRouter (for Quiz Generation) & Fal.ai (for Video Generation)
*   *   **OpenRouter**:
        *   **Role**: Acts as a flexible gateway to various Large Language Models (LLMs) for generating dynamic, multiple-choice quizzes based on chapter content and educational context (grade, board).
        *   **Justification**: Provides access to cutting-edge LLMs for high-quality, relevant quiz generation. Its flexible and usage-based pricing model aligns with budget constraints, as costs scale directly with content generation requests.
*   *   **Fal.ai**:
        *   **Role**: Programmatically creates short, engaging educational videos from text prompts or scripts, fulfilling the core feature of AI-generated video lessons.
        *   **Justification**: Enables on-demand, dynamic video content creation, a unique and innovative aspect of Gyan-Ai. While video generation is a longer process (30-60 seconds), Fal.ai allows the system to produce tailored visual content without manual creation, addressing the core value proposition.
*   **Cloud Storage for Videos**: Google Cloud Storage (or AWS S3)
    *   **Role**: To store the video files generated by Fal.ai, making them accessible via public URLs for streaming within the Flutter application.
    *   **Justification**: Provides highly scalable, durable, and cost-effective object storage for media assets, essential for serving video content efficiently.

3.  SUPPORTING INFRASTRUCTURE & TOOLS

3.1. CI/CD (Continuous Integration/Continuous Deployment)

*   **Technology**: GitHub Actions
*   **Role**: Automates the software delivery pipeline. This includes linting, running tests (unit, integration, E2E), building the Flutter application for TestFlight/Google Play Internal Testing, and deploying the backend to staging and production environments.
*   **Justification**: Native integration with GitHub repositories, widely adopted, and flexible. Ensures code quality through automated checks, accelerates deployment cycles (critical for a 14-week MVP timeline), and reduces manual errors. Production deployments will require manual approval.

3.2. Logging, Monitoring & Error Reporting

*   **Logging**: Cloud Provider's Native Solution (e.g., Google Cloud Logging)
    *   **Role**: Centralized aggregation and management of logs generated by backend services.
    *   **Justification**: Seamless integration with serverless functions and platform infrastructure, facilitating efficient debugging, performance analysis, and operational insights.
*   **Monitoring**: Grafana (or similar cloud-native dashboards)
    *   **Role**: Visualization of key backend performance metrics (e.g., API latency, error rates, resource utilization, AI service call durations).
    *   **Justification**: Provides real-time operational visibility, allowing proactive identification of performance bottlenecks and system health issues, essential for maintaining the 99.5% uptime SLA.
*   **Error Reporting**: Sentry
    *   **Role**: Real-time capture, aggregation, and reporting of crashes and errors from both the Flutter mobile application and the backend services.
    *   **Justification**: Crucial for maintaining application stability and quality. Sentry provides immediate alerts with detailed stack traces, facilitating rapid debugging and resolution of issues, which is vital given the emphasis on user satisfaction and a smooth learning experience.

3.3. Automated Testing Strategy

*   **Types & Tools**:
    *   **Unit Tests**: For individual functions/widgets in both backend (e.g., Jest for Node.js) and frontend (e.g., `test` package for Dart/Flutter).
    *   **Integration Tests**: To verify communication between the Flutter app and backend APIs.
    *   **End-to-End (E2E) Tests**: Using Flutter's `integration_test` package to automate critical user flows (e.g., "User Registration", "Login", "Complete a Quiz").
*   **Justification**: Ensures code quality, prevents regressions, and validates core user journeys. This comprehensive testing strategy is fundamental for delivering a stable MVP within the aggressive timeline and for long-term maintainability.

3.4. Environment Management

*   **Environments**:
    *   **Development (dev)**: For local developer workstations.
    *   **Staging (staging)**: A near-production environment for final testing and QA before deployment.
    *   **Production (prod)**: The live environment serving end-users.
*   **Justification**: Provides isolated and consistent environments, minimizing risks associated with deploying changes directly to production and allowing for thorough testing of new features.

3.5. Third-Party Integrations (MVP)

*   **Analytics**: Firebase Analytics
    *   **Role**: Track critical user events, screen views, and conversion funnels to measure MVP success metrics (e.g., activation rate, retention).
    *   **Justification**: Free, robust, and integrates seamlessly with Flutter, providing invaluable insights into user behavior and application performance.

3.6. Planned Integrations (Post-MVP)

*   **Push Notifications**: Firebase Cloud Messaging (FCM)
*   **External Authentication**: Google Sign-In, Sign in with Apple
*   **CDN for Video Streaming**: AWS CloudFront (or Google Cloud CDN)
    *   **Role**: To cache and serve video content globally, reducing latency and improving streaming experience as user base and geographic distribution grow.

4.  OVERALL JUSTIFICATION & RATIONALE

The chosen technology stack for Gyan-Ai is a strategic blend designed to meet the MVP's aggressive timeline and budget constraints while establishing a foundation for future scalability and innovation.

*   **Scalability**: The entire architecture (Flutter, serverless backend, Neon, cloud storage, AI APIs) is inherently designed for automatic scaling to handle anticipated user growth and peak loads without significant operational overhead.
*   **Cost-Effectiveness**: Leaning heavily on serverless and usage-based pricing models for infrastructure (Neon, cloud functions/backend) and AI services (OpenRouter, Fal.ai) minimizes fixed costs, making it sustainable for an early-stage product.
*   **Development Velocity**: Cross-platform development with Flutter, a lightweight backend, and leveraging powerful, pre-built AI APIs significantly reduces development time, aligning with the 14-week MVP target.
*   **Maintainability & Reliability**: A modular, API-driven architecture, coupled with a robust CI/CD pipeline, comprehensive testing, and real-time error reporting (Sentry), ensures high code quality, stability, and ease of future maintenance.
*   **Innovation**: The core of Gyan-Ai's value proposition lies in its use of generative AI. The selected AI APIs are at the forefront of this technology, enabling dynamic and personalized educational content creation that sets Gyan-Ai apart.

## Project Structure
PROJECTSTRUCTURE

This document outlines the standard file and folder organization for the "Gyan-Ai" project. This structure promotes modularity, maintainability, and scalability, aligning with best practices for multi-platform applications and serverless backends.

```
.
├── .github/                       # GitHub Actions workflows for CI/CD
├── backend/                       # Server-side application (Node.js/Express or Python/FastAPI)
├── docs/                          # Project documentation, API specs, architecture diagrams
├── frontend/                      # Flutter mobile application
├── infra/                         # Infrastructure-as-code and database specific files
├── scripts/                       # Utility scripts for development, deployment, and database management
├── .gitignore                     # Specifies intentionally untracked files to ignore
├── LICENSE                        # Project licensing information
└── README.md                      # Project overview, setup instructions, and quick start guide
```

---

### `backend/`

This directory contains the source code for the "Gyan-Ai" backend API. It's structured to separate concerns, making it easier to manage routes, business logic, data models, and external integrations.

```
backend/
├── src/                           # Main source code directory
│   ├── app.js                     # Main application entry point, server setup (e.g., Express app)
│   ├── config/                    # Configuration files for different environments
│   │   ├── index.js               # Central configuration loader
│   │   └── environments/          # Environment-specific configuration
│   │       ├── development.js
│   │       ├── staging.js
│   │       └── production.js
│   ├── controllers/               # Request handlers, orchestrate business logic for routes
│   │   ├── auth.controller.js     # Handles user authentication requests
│   │   ├── curriculum.controller.js # Handles curriculum data requests
│   │   └── content.controller.js    # Handles content (video/quiz) generation and retrieval requests
│   ├── middleware/                # Express/FastAPI middleware functions
│   │   ├── auth.middleware.js     # Authentication middleware (e.g., JWT verification)
│   │   ├── error.middleware.js    # Centralized error handling middleware
│   │   └── logger.middleware.js   # Request logging middleware
│   ├── models/                    # Database models and schema definitions
│   │   ├── user.model.js          # User schema (users table)
│   │   ├── board.model.js         # Educational board schema (boards table)
│   │   ├── class.model.js         # Class schema (classes table)
│   │   ├── subject.model.js       # Subject schema (subjects table)
│   │   ├── chapter.model.js       # Chapter schema (chapters table)
│   │   ├── content.model.js       # Content schema (content table, stores video/quiz data)
│   │   ├── user_progress.model.js # User progress schema (user_progress table)
│   │   └── quiz_attempt.model.js  # Quiz attempt schema (quiz_attempts table)
│   ├── routes/                    # API route definitions
│   │   ├── index.js               # Aggregates all specific routes
│   │   ├── auth.routes.js         # Routes for user authentication
│   │   ├── curriculum.routes.js   # Routes for curriculum navigation
│   │   └── content.routes.js      # Routes for accessing and generating content
│   ├── services/                  # Core business logic and external API integrations
│   │   ├── auth.service.js        # User authentication logic, token generation
│   │   ├── curriculum.service.js  # Logic for retrieving and structuring curriculum data
│   │   ├── ai_generation.service.js # Orchestrates calls to OpenRouter (quiz) and Fal.ai (video)
│   │   ├── database.service.js    # Database connection and generic query utilities
│   │   └── storage.service.js     # Cloud storage integration (e.g., Google Cloud Storage/AWS S3 for videos)
│   └── utils/                     # Utility functions and helper modules
│       ├── api_error.js           # Custom error classes for API responses
│       ├── constants.js           # Shared constants (e.g., magic strings, enum values)
│       └── validator.js           # Data validation utilities
├── tests/                         # Unit and integration tests for backend components
│   ├── unit/                      # Unit tests for individual functions/modules
│   └── integration/               # Integration tests for API endpoints and service interactions
├── .env.example                   # Example environment variables file
├── package.json                   # Project metadata and dependency list (for Node.js)
├── package-lock.json              # Specific dependency versions (for Node.js)
└── README.md                      # Backend-specific README with setup and run instructions
```

---

### `frontend/`

This directory contains the source code for the "Gyan-Ai" Flutter mobile application. It follows a feature-first architecture, also known as domain-driven design or Clean Architecture, to keep code organized and maintainable.

```
frontend/
├── lib/                           # Flutter's main source code directory
│   ├── main.dart                  # Application entry point
│   ├── src/                       # Core application logic and features
│   │   ├── app.dart               # Root widget, theme, and global providers
│   │   ├── core/                  # Shared components, utilities, and foundational elements
│   │   │   ├── constants/         # App-wide constants (e.g., API endpoints, route names)
│   │   │   ├── errors/            # Custom exception and failure classes
│   │   │   ├── network/           # API client, interceptors, network status checker
│   │   │   ├── utils/             # General utility functions (e.g., date formatting, validators)
│   │   │   └── widgets/           # Reusable UI widgets shared across features
│   │   ├── features/              # Feature-specific modules, organized by core user journeys
│   │   │   ├── auth/              # User registration, login, profile setup
│   │   │   │   ├── data/          # Repositories, data sources (e.g., API calls, local storage)
│   │   │   │   ├── domain/        # Models, entities, use cases for authentication
│   │   │   │   └── presentation/  # UI widgets, blocs/providers for authentication screens
│   │   │   ├── curriculum/        # Board, class, subject, and chapter navigation
│   │   │   │   ├── data/
│   │   │   │   ├── domain/
│   │   │   │   └── presentation/
│   │   │   ├── content/           # Video player, quiz display, content fetching and interaction
│   │   │   │   ├── data/
│   │   │   │   ├── domain/
│   │   │   │   └── presentation/
│   │   │   ├── home/              # Main dashboard and navigation hub
│   │   │   │   ├── data/
│   │   │   │   ├── domain/
│   │   │   │   └── presentation/
│   │   │   └── profile/           # User profile management, progress tracking
│   │   │       ├── data/
│   │   │       ├── domain/
│   │   │       └── presentation/
│   │   ├── routes/                # Centralized route definitions and navigation logic
│   │   └── services/              # Integrations with third-party services
│   │       ├── analytics_service.dart # Firebase Analytics integration
│   │       ├── error_service.dart # Sentry integration for error reporting
│   │       └── notification_service.dart # Firebase Cloud Messaging (FCM) integration (post-MVP)
│   └── data/                      # General data models/repositories (if not tied to a specific feature)
│   └── domain/                    # General domain models/use cases
├── assets/                        # Static application assets
│   ├── images/                    # Logos, icons, illustrations
│   ├── fonts/                     # Custom fonts
│   └── lottie/                    # Lottie animations for loading states, success messages, etc.
├── test/                          # Unit and widget tests for Flutter components
│   ├── unit_tests/
│   └── widget_tests/
├── integration_test/              # End-to-end (E2E) tests for critical user flows
│   └── app_test.dart
├── pubspec.yaml                   # Flutter project dependencies and metadata
├── pubspec.lock                   # Specific dependency versions
├── analysis_options.yaml          # Linting rules for Dart code
└── README.md                      # Frontend-specific README with setup and run instructions
```

---

### `docs/`

This directory stores all project documentation, including architectural decisions, API specifications, and database schemas.

```
docs/
├── api/                           # API documentation (e.g., OpenAPI/Swagger specifications)
│   └── openapi.yaml               # OpenAPI specification for the backend API
├── architecture/                  # High-level architecture, design decisions, diagrams
│   ├── overview.md                # High-level system overview and component interaction
│   └── decision_log.md            # Document for significant architectural decisions
├── database/                      # Database schema and migration information
│   └── schema.drawio              # Visual schema diagram (e.g., using Draw.io)
├── project_plan.md                # Detailed project plan and scope
└── README.md                      # Overview of documentation structure
```

---

### `infra/`

This directory contains infrastructure-as-code definitions and database-specific configuration for deploying and managing project resources.

```
infra/
├── neon/                          # Neon (Serverless Postgres) specific files
│   ├── schema.sql                 # Initial database schema definition
│   └── migrations/                # Database migration scripts (e.g., using Flyway or similar)
│       ├── V1__initial_schema.sql
│       └── V2__add_user_progress.sql
└── serverless_configs/            # Configuration files for serverless functions (if using framework like Serverless.com)
    └── service.yml                # Main serverless configuration file
```

---

### `scripts/`

This directory holds various utility scripts to automate common development, deployment, and maintenance tasks.

```
scripts/
├── db/                            # Database related utility scripts
│   ├── seed.js                    # Script to populate initial curriculum data into the database
│   └── migrate.js                 # Script to apply database migrations
├── deploy.sh                      # Shell script for deploying the application (e.g., to staging/production)
└── start_dev.sh                   # Script to start local development environments (e.g., backend + frontend)
```

---

### `.github/`

This directory contains GitHub Actions workflow definitions for Continuous Integration and Continuous Deployment (CI/CD).

```
.github/
└── workflows/
    ├── flutter_ci.yml             # Workflow for Flutter linting, testing, and building
    ├── backend_ci.yml             # Workflow for backend linting, testing, and building
    └── deploy.yml                 # Workflow for deployment to staging/production environments
```

## Database Schema Design
**SCHEMADESIGN**

**1. Introduction**
The Gyan AI database schema is designed to support the core functionality of the MVP, focusing on user management, curriculum structure, AI-generated content storage, and tracking user progress. The design emphasizes clarity, flexibility, and scalability, leveraging a relational model to manage hierarchical educational content efficiently.

**2. Database Technology**
The project utilizes **Neon (Serverless Postgres)** as its primary database. Postgres's robust relational capabilities, JSONB support, and serverless nature align well with the MVP's requirements for strong consistency, data integrity, and cost-effective scalability.

**3. Core Data Models (Tables)**

The following tables form the backbone of the Gyan AI application for the MVP:

**3.1. `users` Table**
Stores user authentication details and their selected curriculum preferences.

- `id` (UUID, Primary Key): Unique identifier for the user.

- `email` (VARCHAR(255), Unique, Not Null): User's email address, used for login.

- `password_hash` (VARCHAR(255), Not Null): Hashed password for secure authentication.

- `board_id` (UUID, Foreign Key to `boards.id`, Nullable): The educational board selected by the user. Nullable initially until selected during onboarding.

- `class_id` (UUID, Foreign Key to `classes.id`, Nullable): The class selected by the user. Nullable initially until selected during onboarding.

- `created_at` (TIMESTAMP WITH TIME ZONE, Default NOW(), Not Null): Timestamp of user creation.

- `updated_at` (TIMESTAMP WITH TIME ZONE, Default NOW(), ON UPDATE NOW(), Not Null): Last update timestamp for the user record.

**3.2. `boards` Table**
Defines the educational boards available in the system.

- `id` (UUID, Primary Key): Unique identifier for the board.

- `name` (VARCHAR(100), Unique, Not Null): Name of the board (e.g., "CBSE", "ICSE", "State Board").

**3.3. `classes` Table**
Lists the educational classes under each board.

- `id` (UUID, Primary Key): Unique identifier for the class.

- `board_id` (UUID, Foreign Key to `boards.id`, Not Null): Links a class to its respective board.

- `class_number` (INTEGER, Not Null): The numerical representation of the class (e.g., 5, 6, ..., 10).

**3.4. `subjects` Table**
Organizes subjects offered within each class.

- `id` (UUID, Primary Key): Unique identifier for the subject.

- `class_id` (UUID, Foreign Key to `classes.id`, Not Null): Links a subject to its respective class.

- `name` (VARCHAR(255), Not Null): Name of the subject (e.g., "Physics", "History", "Mathematics").

**3.5. `chapters` Table**
Details the chapters within each subject.

- `id` (UUID, Primary Key): Unique identifier for the chapter.

- `subject_id` (UUID, Foreign Key to `subjects.id`, Not Null): Links a chapter to its respective subject.

- `name` (VARCHAR(255), Not Null): Name of the chapter (e.g., "Laws of Motion", "The Mughal Empire").

- `chapter_number` (INTEGER, Not Null): The order or number of the chapter within the subject.

**3.6. `content` Table**
Stores the AI-generated educational content (videos and quizzes).

- `id` (UUID, Primary Key): Unique identifier for the content item.

- `chapter_id` (UUID, Foreign Key to `chapters.id`, Not Null): Links the content to its corresponding chapter.

- `content_type` (ENUM('video', 'quiz'), Not Null): Specifies the type of content stored.

- `content_data` (JSONB, Not Null): A flexible JSON field to store content-specific details.

  - For `content_type` = 'video': `{\"video_url\": \"[URL to video on cloud storage]\", \"duration\": [integer in seconds]}`

  - For `content_type` = 'quiz': `{\"questions\": [{\"q\": \"[Question text]\", \"options\": [\"[Option A]\", \"[Option B]\", \"[Option C]\", \"[Option D]\"], \"answer\": \"[Correct option text]\"}, ...]}`

- `created_at` (TIMESTAMP WITH TIME ZONE, Default NOW(), Not Null): Timestamp when the content was generated and stored.

**3.7. `user_progress` Table**
Tracks which content items a user has completed.

- `id` (UUID, Primary Key): Unique identifier for the progress record.

- `user_id` (UUID, Foreign Key to `users.id`, Not Null): Links the progress record to a specific user.

- `content_id` (UUID, Foreign Key to `content.id`, Not Null): Links the progress record to a specific content item.

- `status` (ENUM('completed'), Not Null): Current status of the content for the user. For MVP, only 'completed' is tracked.

- `completed_at` (TIMESTAMP WITH TIME ZONE, Default NOW(), Not Null): Timestamp when the content was marked as completed.

**3.8. `quiz_attempts` Table**
Records a user's attempts and scores on quizzes.

- `id` (UUID, Primary Key): Unique identifier for the quiz attempt record.

- `user_id` (UUID, Foreign Key to `users.id`, Not Null): Links the quiz attempt to a specific user.

- `quiz_content_id` (UUID, Foreign Key to `content.id`, Not Null): Links the attempt to a specific quiz content item (where `content.content_type` = 'quiz').

- `score` (INTEGER, Not Null): The user's score on that quiz attempt.

- `total_questions` (INTEGER, Not Null): Total number of questions in the quiz.

- `attempted_at` (TIMESTAMP WITH TIME ZONE, Default NOW(), Not Null): Timestamp of when the quiz was attempted.

**4. Relationships**

The tables are interconnected using foreign keys to establish a clear relational structure:


- **One-to-Many Relationships:**

  - `boards` to `classes`: A board can have multiple classes.

  - `classes` to `subjects`: A class can have multiple subjects.

  - `subjects` to `chapters`: A subject can have multiple chapters.

  - `chapters` to `content`: A chapter can have multiple content items (e.g., a video and a quiz).

  - `users` to `user_progress`: A user can have progress records for multiple content items.

  - `users` to `quiz_attempts`: A user can make multiple quiz attempts.

  - `content` to `user_progress`: A content item can be completed by multiple users.

  - `content` to `quiz_attempts`: A quiz content item can be attempted multiple times by multiple users.


- **Many-to-One Relationships (User-Curriculum Selection):**

  - `users` refers to `boards` via `board_id` (user's selected board).

  - `users` refers to `classes` via `class_id` (user's selected class).

**5. Key Design Considerations**


- **UUID Primary Keys:** Using UUIDs ensures globally unique identifiers, simplifying distributed system design and preventing ID collisions, especially beneficial in a serverless environment like Neon.

- **JSONB for Flexible Content:** The `content_data` field in the `content` table utilizes Postgres's JSONB data type. This provides schema flexibility for different content types (video vs. quiz) without requiring separate tables, while still allowing efficient querying and indexing of JSON fields if needed in the future.

- **Hierarchical Curriculum:** The nested structure of `boards` -> `classes` -> `subjects` -> `chapters` allows for clear content organization and efficient querying based on a user's selected curriculum.

- **User Progress Tracking:** Dedicated tables (`user_progress`, `quiz_attempts`) provide detailed tracking of user interaction and performance, which is crucial for the gamification elements and future analytics features.

- **Timestamp Fields:** `created_at` and `updated_at` fields are included in key tables for auditing, data freshness tracking, and potential future features like content versioning.

- **ENUM Types:** Using `ENUM` for `content_type` and `status` enforces data integrity by restricting values to predefined options, improving readability and maintainability.

- **Nullability:** Carefully considered nullability for fields like `board_id` and `class_id` in the `users` table to accommodate the user onboarding flow where these selections are made after initial registration.

## User Flow
Gyan-Ai: User Flow Documentation

This document outlines the primary user journeys within the Gyan-Ai MVP, detailing the interaction patterns, screen elements, and system responses for key functionalities.

---

**1. User Flow: New User Registration & Curriculum Selection**

**Trigger:** User opens the app for the first time or taps "Sign Up" on the Welcome/Login screen.
**Actors:** Rohan (The Student)
**Pre-conditions:** User has downloaded and launched the Gyan-Ai app.
**Post-conditions:** User account is created, board and class are saved to their profile, and they are logged in and presented with relevant content.

**1.1. Screen: Welcome / Splash Screen**
*   **Description:** An initial screen introducing Gyan-Ai. May display the brand logo and a tagline.
*   **UI Elements:**
    *   Gyan-Ai Logo
    *   Tagline: "Your AI-Powered Learning Companion"
    *   Button: "Get Started"
    *   Text Link: "Already have an account? Log In"
*   **User Actions:** Taps "Get Started".
*   **System Responses:** Navigates to the "Create Account" screen.
*   **Navigation:** -> Create Account Screen

**1.2. Screen: Create Account**
*   **Description:** Collects basic user information for registration.
*   **UI Elements:**
    *   Header: "Create Your Account"
    *   Input Field: "Email Address" (Keyboard: email, Validation: email format)
    *   Input Field: "Password" (Keyboard: text, Secure Entry: yes, Validation: min 8 chars, 1 uppercase, 1 number)
    *   Input Field: "Confirm Password" (Keyboard: text, Secure Entry: yes, Validation: must match Password)
    *   Button: "Sign Up" (Disabled until all fields are valid)
    *   Text Link: "Already have an account? Log In"
*   **User Actions:** Enters email, password, and confirms password. Taps "Sign Up".
*   **System Responses:**
    *   If successful: Calls backend API to register user. Logs user in. Navigates to "Select Curriculum" screen.
    *   If email already exists: Displays error "Email already registered. Please Log In or use a different email."
    *   If password validation fails: Displays inline error for respective field.
*   **Navigation:**
    *   Success: -> Select Curriculum Screen
    *   Error (Email exists): Remains on screen, displays error.

**1.3. Screen: Select Curriculum**
*   **Description:** Guides the user to select their educational board and class. This choice determines the content they will see.
*   **UI Elements:**
    *   Header: "Tell Us About Your Studies"
    *   Sub-header: "Select your Educational Board:"
    *   Radio Buttons / Segmented Control: "CBSE", "ICSE", "State Board" (User can only select one)
    *   Sub-header: "Select your Class:"
    *   Dropdown / Picker: "Class 5", "Class 6", ..., "Class 10" (User can only select one)
    *   Button: "Continue" (Disabled until both selections are made)
*   **User Actions:** Selects a Board and a Class. Taps "Continue".
*   **System Responses:** Calls backend API to update user profile with selected board and class. Navigates to "Dashboard" screen.
*   **Navigation:** -> Dashboard Screen

---

**2. User Flow: Existing User Login**

**Trigger:** User opens the app and is not logged in, or taps "Log In" on the Welcome/Create Account screen.
**Actors:** Rohan (The Student)
**Pre-conditions:** User has a registered account with Gyan-Ai.
**Post-conditions:** User is logged in and redirected to their personalized dashboard.

**2.1. Screen: Login**
*   **Description:** Allows existing users to sign in to their account.
*   **UI Elements:**
    *   Header: "Welcome Back!"
    *   Input Field: "Email Address" (Keyboard: email)
    *   Input Field: "Password" (Keyboard: text, Secure Entry: yes)
    *   Button: "Log In" (Disabled until both fields have input)
    *   Text Link: "Forgot Password?" (Not MVP scope, will be disabled/placeholder)
    *   Text Link: "Don't have an account? Sign Up"
*   **User Actions:** Enters registered email and password. Taps "Log In".
*   **System Responses:**
    *   If successful: Calls backend API to authenticate user. Logs user in. Navigates to "Dashboard" screen.
    *   If invalid credentials: Displays error "Invalid email or password. Please try again."
*   **Navigation:**
    *   Success: -> Dashboard Screen
    *   Error: Remains on screen, displays error.

---

**3. User Flow: Browse Curriculum & Select Chapter**

**Trigger:** User lands on the Dashboard after login/registration.
**Actors:** Rohan (The Student)
**Pre-conditions:** User is logged in and has selected their Board and Class.
**Post-conditions:** User has successfully navigated to a specific chapter page.

**3.1. Screen: Dashboard**
*   **Description:** The main landing page after login, providing an overview and navigation to subjects.
*   **UI Elements:**
    *   Header: "Hello, Rohan!" (or "Welcome!")
    *   Display: User's selected Board and Class (e.g., "CBSE, Class 9")
    *   Section: "Your Subjects" (List of subjects relevant to the user's selected board/class)
    *   Each Subject Item (e.g., "Physics", "Mathematics", "History"):
        *   Subject Name
        *   Icon
        *   Progress Indicator (Future MVP, placeholder for now)
    *   Gamification: Current Points, Daily Streak (e.g., "500 Points | 3 Day Streak")
    *   Navigation Bar (Bottom): Home, Profile (Future MVP)
*   **User Actions:** Taps on a Subject (e.g., "Physics").
*   **System Responses:** Calls backend API to fetch chapters for the selected subject. Navigates to "Chapter List" screen for that subject.
*   **Navigation:** -> Chapter List Screen (for selected Subject)

**3.2. Screen: Chapter List (e.g., Physics - Class 9)**
*   **Description:** Displays a list of chapters for the selected subject.
*   **UI Elements:**
    *   Header: "Physics - Class 9" (or appropriate Subject & Class)
    *   Back Button: To return to the Dashboard.
    *   List of Chapters:
        *   Each Chapter Item (e.g., "Chapter 1: Motion", "Chapter 2: Force and Laws of Motion"):
            *   Chapter Number & Name
            *   Status Indicator (e.g., "Completed", "Pending", "Started" - Future MVP)
            *   Accessory Icon (e.g., arrow to indicate tappable)
*   **User Actions:** Taps on a specific Chapter (e.g., "Chapter 1: Motion").
*   **System Responses:** Calls backend API to fetch chapter details (including any existing content links for video/quiz). Navigates to "Chapter Detail" screen.
*   **Navigation:** -> Chapter Detail Screen (for selected Chapter)

---

**4. User Flow: Watch AI-Generated Video Lesson**

**Trigger:** User is on a Chapter Detail screen and wants to learn.
**Actors:** Rohan (The Student)
**Pre-conditions:** User is on the "Chapter Detail" screen for a specific chapter.
**Post-conditions:** User has watched the video lesson, earns points, and the video is marked as watched.

**4.1. Screen: Chapter Detail (e.g., Motion - Class 9, Physics)**
*   **Description:** Presents options to learn and test knowledge for a specific chapter.
*   **UI Elements:**
    *   Header: "Chapter 1: Motion"
    *   Back Button: To return to the Chapter List.
    *   Section: "Video Lesson"
        *   Thumbnail / Placeholder Image (e.g., a relevant illustration)
        *   Button: "Watch Lesson"
        *   Status/Duration (e.g., "Not Started", "3 min video")
    *   Section: "Practice Quiz"
        *   Button: "Take Quiz" (Disabled until video is watched for MVP)
        *   Status (e.g., "Pending Video", "Attempt Quiz")
    *   Chapter Summary (Optional, basic text description from AI)
*   **User Actions:** Taps "Watch Lesson".
*   **System Responses:**
    *   If video already exists (cached/pre-generated): Displays a loading spinner briefly, then navigates to "Video Player" screen and starts playback.
    *   If video needs generation: Displays a prominent loading indicator/dialog (e.g., "Generating your lesson video... This may take up to 60 seconds.") while the backend calls Fal.ai. Once generated and stored, navigates to "Video Player" screen and starts playback.
*   **Navigation:** -> Video Player Screen

**4.2. Screen: Video Player**
*   **Description:** Dedicated screen for playing the AI-generated video lesson.
*   **UI Elements:**
    *   Full-screen video player with standard controls (play/pause, scrub, volume).
    *   Chapter Title overlay.
    *   Progress bar.
    *   "Exit" or "Back" button (usually in top left).
    *   (Optional, post-MVP: "Next Chapter" button at end of video)
*   **User Actions:** Watches the video. May pause, replay, adjust volume.
*   **System Responses:**
    *   Upon video completion:
        *   Registers video completion for the user in `user_progress` table.
        *   Awards points (e.g., 50 points) and updates the user's score.
        *   Displays a brief "Lesson Complete! You earned 50 points!" toast/notification.
        *   Updates the "Take Quiz" button state on the Chapter Detail screen to "Available".
    *   If user exits before completion: No points awarded, progress not marked.
*   **Navigation:** -> Chapter Detail Screen (after video completion or user exit)

---

**5. User Flow: Take AI-Generated Chapter Quiz**

**Trigger:** User has completed watching the video lesson for a chapter and is on the Chapter Detail screen.
**Actors:** Rohan (The Student)
**Pre-conditions:** User has watched the video lesson for the current chapter (or explicitly allowed to skip in future iterations) and is on the "Chapter Detail" screen.
**Post-conditions:** User completes the quiz, receives a score, earns points, and the quiz attempt is recorded.

**5.1. Screen: Chapter Detail (e.g., Motion - Class 9, Physics)**
*   **Description:** (Same as 4.1, but with "Take Quiz" button enabled).
*   **UI Elements:**
    *   Section: "Practice Quiz"
        *   Button: "Take Quiz" (Now enabled)
        *   Status (e.g., "Attempt Quiz", "Last Score: 4/5")
*   **User Actions:** Taps "Take Quiz".
*   **System Responses:**
    *   If quiz already exists (cached/pre-generated for this chapter): Displays a loading spinner briefly, then navigates to "Quiz" screen and loads the first question.
    *   If quiz needs generation: Displays a prominent loading indicator/dialog (e.g., "Generating your quiz... This may take a few seconds.") while the backend calls OpenRouter. Once generated, navigates to "Quiz" screen and loads the first question.
*   **Navigation:** -> Quiz Screen

**5.2. Screen: Quiz**
*   **Description:** Presents a series of multiple-choice questions for the chapter.
*   **UI Elements:**
    *   Header: "Chapter 1: Motion Quiz"
    *   Back Button / Exit Quiz (Allows user to abandon, with confirmation).
    *   Question Number / Progress (e.g., "Question 1 of 5")
    *   Question Text.
    *   Multiple Choice Options (Radio buttons, typically 4 options).
    *   Button: "Next Question" (Disabled until an option is selected).
    *   Button: "Submit Quiz" (Only on the final question).
*   **User Actions:** Reads question, selects an option. Taps "Next Question". Repeats until the last question. On the last question, selects an option and taps "Submit Quiz".
*   **System Responses:**
    *   For each "Next Question": Records the user's answer (but doesn't reveal correctness yet). Loads the next question.
    *   On "Submit Quiz":
        *   Calculates the user's score.
        *   Awards points based on correct answers (e.g., 10 points per correct answer).
        *   Records the quiz attempt (score, total questions, time) in `quiz_attempts` table.
        *   Updates user's total points.
        *   Navigates to "Quiz Results" screen.
    *   If user exits early: Displays confirmation "Are you sure you want to quit? Your progress will not be saved." If confirmed, navigates back to Chapter Detail, no points awarded.
*   **Navigation:** -> Quiz Results Screen

**5.3. Screen: Quiz Results**
*   **Description:** Displays the user's performance for the completed quiz.
*   **UI Elements:**
    *   Header: "Quiz Completed!"
    *   Score Display: "You scored X out of Y" (e.g., "You scored 4 out of 5!")
    *   Points Earned: "You earned Z points!"
    *   (Optional, post-MVP: "Review Answers" button, highlights correct/incorrect answers)
    *   Button: "Return to Chapter"
    *   Button: "Explore Other Chapters" (Directs to Dashboard/Chapter List)
    *   Gamification: Updated total points, streak counter if applicable.
*   **User Actions:** Reviews results. Taps "Return to Chapter" or "Explore Other Chapters".
*   **System Responses:** Navigates as requested.
*   **Navigation:** -> Chapter Detail Screen or Dashboard Screen

---

**General Interaction Patterns & UI Considerations:**

*   **Loading States:** For AI-generated content (video, quiz), prominent loading indicators or progress bars will be displayed, along with descriptive messages (e.g., "Generating your custom lesson...").
*   **Error States:** User-friendly error messages will be shown for network issues ("You seem to be offline.") or AI service failures ("Oops! We couldn't generate the content right now."). A "Retry" button will be provided where applicable.
*   **Feedback:** Toast messages or snackbars will confirm successful actions (e.g., "Account created!", "Points awarded!").
*   **Gamification:** Points and daily streaks will be prominently displayed on the Dashboard and updated dynamically. Visual feedback (e.g., small animation) upon earning points.
*   **Navigation:** Consistent use of a back button in the header for hierarchical navigation and a bottom navigation bar for primary sections (Home, Profile).
*   **Accessibility:** All interactive elements will have sufficient tap targets, high contrast, and logical focus order. Text alternatives for icons.
*   **Mobile-First Design:** All screens are optimized for smaller mobile touch interfaces.

## Styling Guidelines
STYLING

1. DESIGN SYSTEM OVERVIEW

The Gyan AI design system aims to create a cohesive, intuitive, and engaging learning experience for students, while also reassuring parents of its quality and trustworthiness. Our aesthetic is characterized by a clean, minimalist, and colorful approach that is stimulating without being distracting. The core principles revolve around simplicity, clarity, and consistency to ensure a seamless user journey from onboarding to content consumption and assessment.

2. BRAND IDENTITY

*   **Name:** Gyan AI
*   **Personality:** Encouraging, Modern, Simple, Trustworthy.
*   **Aesthetic:** Clean, minimalist, and colorful. Designed to be engaging for students without causing distraction, reflecting a focus on learning.
*   **Logo:** A simple, modern logo combining a brain/lightbulb icon with the letter "G". This symbolizes knowledge ("Gyan"), intelligence, and the AI aspect of the platform.

3. COLOR PALETTE

Our color palette is carefully selected to evoke specific emotions and guide user attention, aligning with our brand personality.

*   **Primary Color: Deep Blue**
    *   **Hex Code:** #4A90E2
    *   **Usage:** Used for primary branding elements, navigation bars, important text, and background accents. Conveys trustworthiness, stability, and intelligence.

*   **Secondary/Accent Color: Vibrant Orange**
    *   **Hex Code:** #F5A623
    *   **Usage:** Employed for call-to-action (CTA) buttons, interactive elements, progress indicators, and gamification rewards (e.g., points, streaks). Signifies energy, enthusiasm, and encouragement.

*   **Neutral Colors:**
    *   **Light Gray (Backgrounds):** #F2F2F7
        *   **Usage:** Predominantly for screen backgrounds and card containers. Provides a clean, spacious feel and reduces visual clutter.
    *   **Dark Gray (Text):** #333333
        *   **Usage:** Primary color for body text and secondary headings. Ensures high readability against lighter backgrounds.
    *   **Mid Gray (Borders/Dividers):** #CCCCCC
        *   **Usage:** For subtle borders, dividers, and disabled states. Offers clear visual separation without being obtrusive.

4. TYPOGRAPHY

Readability is paramount for an educational app. We utilize a clean and friendly sans-serif typeface to ensure clarity across all content types.

*   **Font Family:** Poppins or Lato
    *   **Rationale:** Both Poppins and Lato are modern, highly readable sans-serif fonts that work well across various screen sizes and text densities. Their friendly appearance aligns with Gyan AI's encouraging personality.
*   **Usage:**
    *   **Headings:** Used for main titles, section headers, and chapter names. Larger weights and sizes will be employed to establish hierarchy.
    *   **Body Text:** Used for lesson explanations, quiz questions, descriptions, and UI labels. Optimized for comfortable reading over extended periods.
    *   **Interactive Elements:** Buttons, links, and form fields will also use this typeface to maintain consistency.
*   **Hierarchy:** A clear typographic scale will be defined to distinguish between different levels of information (e.g., H1, H2, Body, Caption).

5. UI/UX PRINCIPLES

Our UI/UX design is grounded in principles that promote usability, engagement, and accessibility, drawing inspiration from leading educational and consumer apps.

*   **Design Inspirations:**
    *   **Duolingo:** Valued for its simple, card-based UI, intuitive gamification elements (streaks, points), and encouraging user feedback. This approach helps maintain user motivation and makes learning feel rewarding.
    *   **Khan Academy:** Admired for its no-nonsense, content-first approach to displaying educational material. This ensures that the learning content is always the focal point, minimizing distractions.

*   **Core Usability Heuristics (Nielsen's Principles):**
    *   **Aesthetic and Minimalist Design:** We strive for clean interfaces that present only relevant information, reducing cognitive load and avoiding clutter.
    *   **Consistency and Standards:** Uniform design elements, icons, and interaction patterns will be used throughout the app to ensure predictability and ease of learning.
    *   **User Control and Freedom:** Users should always feel in control, with clear ways to navigate back, pause content, or retry actions.
    *   **Help and Documentation:** Although minimal for MVP, clear error messages and intuitive design will act as "help" in critical moments.

*   **Accessibility (WCAG 2.1 Level AA Compliance Target):**
    *   **Color Contrast:** All text and important UI elements will meet minimum contrast ratios to ensure readability for users with visual impairments.
    *   **Large Tap Targets:** Interactive elements (buttons, links) will have a minimum tap target size of 44x44 dp to facilitate easy interaction, especially on mobile devices.
    *   **Text Alternatives for Icons:** All purely decorative icons will be marked as such, and informative icons will have appropriate text descriptions (e.g., via semantic labels for screen readers).
    *   **Scalable Text:** Users should be able to adjust font sizes through system settings, and the UI should adapt gracefully.

*   **Gamification (MVP Implementation):**
    *   **Simple Points System:** Users will earn points for completing key actions:
        *   Watching an AI-generated video lesson.
        *   Answering quiz questions correctly.
    *   **"Daily Streak" Counter:** A visible counter will encourage consistent app usage by tracking consecutive days of engagement.
    *   **Encouraging Feedback:** Positive visual and auditory cues for correct answers and task completion to reinforce learning and motivation.

*   **Content Presentation:**
    *   **Clear Hierarchy:** Content navigation will follow a clear, hierarchical path (Board -> Class -> Subject -> Chapter), visually reinforcing the structured learning journey.
    *   **Card-Based UI:** Information will often be presented within clear, digestible cards (e.g., for subjects, chapters, quiz questions) to make browsing and selection intuitive.
    *   **Focus on Content:** Video players and quiz interfaces will be designed to minimize distractions, putting the learning material front and center.

*   **Error Handling (UI Specifics):**
    *   **User-Friendly Messages:** When AI services fail or network issues occur, the app will display clear, non-technical error messages (e.g., ""Oops! We couldn't generate the content right now. Please check your connection and try again in a moment."").
    *   **"Retry" Button:** Error messages for transient issues will include an explicit "Retry" button.
    *   **Dedicated Offline Messaging:** If the user attempts to access content while offline, a specific message will be displayed: ""You seem to be offline. Please connect to the internet to continue learning.""

*   **Feedback & Interactions:**
    *   **Smooth Transitions:** Animations and transitions will be subtle and purposeful, enhancing the user experience without causing delays or distraction.
    *   **Immediate Feedback:** User actions (e.g., tapping a button, submitting a quiz answer) will receive immediate visual or haptic feedback to confirm the action.

By adhering to these styling guidelines, Gyan AI will deliver a learning companion that is not only functional and powerful but also delightful and effective for its target audience.
